#!/usr/bin/env bun

import { Analyzer } from './Analyzer';
import { AnalyzerConfig } from './AnalyzerConfig';
import { writeFile, readFile, copyFile, mkdir } from 'fs/promises';
import path from 'path';
import { ContextApp } from './Types';
import { existsSync } from 'fs';

interface DesignSystemWrapperConfig {
  import: string;
  exportType: 'default' | string;
  props?: Record<string, any>;
}

interface DesignSystemInitConfig {
  import: string;
  exportType: 'default' | 'named';
  functionName?: string;
  args?: Record<string, any>;
}

interface DesignSystemConfig {
  css?: string[];
  wrapper?: DesignSystemWrapperConfig | null;
  init?: DesignSystemInitConfig | null;
}

interface PreviewConfig {
  designSystem?: DesignSystemConfig;
}

interface TranslationConfig {
  name: string;
  sourceDir: string;
  rootDir: string;
  ignore: string[];
  excludeComponents: string[];
  preview?: PreviewConfig;
}

/**
 * Load translation.config.json from project root
 */
async function loadConfig(): Promise<TranslationConfig> {
  const configPath = path.join(process.cwd(), 'translation.config.json');
  try {
    const configContent = await readFile(configPath, 'utf-8');
    return JSON.parse(configContent);
  } catch (error) {
    console.error('Error loading translation.config.json:', error);
    console.error('Please create a translation.config.json file in the project root.');
    process.exit(1);
  }
}

/**
 * Convert config to AnalyzerConfig
 */
function configToAnalyzerConfig(config: TranslationConfig): AnalyzerConfig {
  return {
    rootPath: path.join(process.cwd(), config.sourceDir),
    entryPoints: ['App.tsx'],
    analysisLevel: 'fast',
    ignore: config.ignore,
    appName: config.name,
  };
}

/**
 * Detect if a component uses default or named export
 */
async function detectExportType(filePath: string, componentName: string): Promise<'default' | 'named'> {
  try {
    const content = await readFile(filePath, 'utf-8');

    // Check for default export
    const hasDefaultExport = /export\s+default\s+(function|class|const|let)/.test(content);

    // Check for named export matching the component name
    const namedExportPattern = new RegExp(`export\\s+(const|function|class)\\s+${componentName}\\b`);
    const hasNamedExport = namedExportPattern.test(content);

    if (hasDefaultExport) {
      return 'default';
    } else if (hasNamedExport) {
      return 'named';
    }

    // Default to named if we can't determine
    return 'named';
  } catch (error) {
    console.warn(`Warning: Could not detect export type for ${componentName}, defaulting to named`);
    return 'named';
  }
}

/**
 * Generate ComponentBundle.ts from context.json
 * This creates static imports for all components to enable type-safe component rendering
 */
async function generateComponentBundle(contextApp: ContextApp, config: TranslationConfig): Promise<void> {
  const components = Object.values(contextApp.components);

  // Filter out excluded components
  const includedComponents = components.filter(
    c => !config.excludeComponents.includes(c.name)
  );

  // Generate import statements with proper export detection
  const imports = await Promise.all(includedComponents.map(async (component) => {
    // Convert absolute path to relative import from ComponentBundle.ts location
    const absolutePath = component.path;
    const componentBundlePath = path.join(process.cwd(), 'engine', 'ComponentBundle.ts');
    let relativePath = path.relative(path.dirname(componentBundlePath), absolutePath);

    // Convert to posix style (forward slashes) for import statements and remove extension
    const importPath = relativePath.split(path.sep).join('/').replace(/\.tsx?$/, '');

    // Detect export type
    const exportType = await detectExportType(absolutePath, component.name);

    // Generate appropriate import statement
    const importStatement = exportType === 'default'
      ? `import ${component.name} from './${importPath}';`
      : `import { ${component.name} } from './${importPath}';`;

    return importStatement;
  }));

  const importsString = imports.join('\n');

  // Generate registration calls
  const registrations = includedComponents.map(component => {
    return `        this.register('${component.id}', ${component.name}, '${component.name}', '${component.path}');`;
  }).join('\n');

  // Generate the complete file content
  const fileContent = `/**
 * Component Bundle
 *
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by: bun run context:build
 *
 * This file is automatically generated from context.json and translation.config.json
 * It provides static imports for all components to enable type-safe rendering in the preview.
 */

import type { ComponentType } from 'react';

// Component imports
${importsString}

export interface ComponentRegistryEntry {
    component: ComponentType<any>;
    name: string;
    path: string;
}

class ComponentRegistry {
    private components: Map<string, ComponentRegistryEntry> = new Map();

    constructor() {
        this.registerComponents();
    }

    private registerComponents() {
        // Register all components (IDs match context.json)
${registrations}
    }

    private register(id: string, component: ComponentType<any>, name: string, path: string) {
        this.components.set(id, { component, name, path });
    }

    getComponent(id: string): ComponentRegistryEntry | undefined {
        return this.components.get(id);
    }

    getAllComponents(): Map<string, ComponentRegistryEntry> {
        return this.components;
    }
}

export const componentRegistry = new ComponentRegistry();
`;

  // Write to ComponentBundle.ts
  const outputPath = path.join(process.cwd(), 'engine', 'ComponentBundle.ts');
  await writeFile(outputPath, fileContent);

  console.log(`Component bundle generated: ${outputPath}`);
  console.log(`Registered ${includedComponents.length} component(s)`);
}

/**
 * Copy CSS files and generate ComponentStyleBundle.ts
 * Maps component IDs to their CSS file paths
 */
async function generateStyleBundle(contextApp: ContextApp, config: TranslationConfig): Promise<void> {
  const components = Object.values(contextApp.components);

  // Filter out excluded components and those without CSS imports
  const componentsWithCSS = components.filter(
    c => !config.excludeComponents.includes(c.name) && c.cssImports && c.cssImports.length > 0
  );

  // Always create the bundle file (even if empty) to avoid import errors

  // Create CSS output directory if it doesn't exist
  const cssOutputDir = path.join(process.cwd(), 'engine', 'styles');
  if (!existsSync(cssOutputDir)) {
    await mkdir(cssOutputDir, { recursive: true });
  }

  // Copy CSS files and build mapping
  const cssMapping: Record<string, string[]> = {};
  let copiedCount = 0;

  for (const component of componentsWithCSS) {
    const copiedPaths: string[] = [];

    for (const cssPath of component.cssImports) {
      if (existsSync(cssPath)) {
        // Create a unique name: componentId_originalFileName.css
        const originalName = path.basename(cssPath);
        const uniqueName = `${component.id}_${originalName}`;
        const destPath = path.join(cssOutputDir, uniqueName);

        try {
          await copyFile(cssPath, destPath);
          // Store relative path from engine directory
          copiedPaths.push(`./styles/${uniqueName}`);
          copiedCount++;
        } catch (error) {
          console.warn(`Warning: Failed to copy CSS file ${cssPath}:`, error);
        }
      } else {
        console.warn(`Warning: CSS file not found: ${cssPath}`);
      }
    }

    if (copiedPaths.length > 0) {
      cssMapping[component.id] = copiedPaths;
    }
  }

  // Generate ComponentStyleBundle.ts
  const fileContent = `/**
 * Component Style Bundle
 *
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by: bun run context:build
 *
 * This file maps component IDs to their CSS file paths
 */

export const componentStyles: Record<string, string[]> = ${JSON.stringify(cssMapping, null, 2)};

/**
 * Get CSS file paths for a component
 */
export function getComponentStyles(componentId: string): string[] {
  return componentStyles[componentId] || [];
}
`;

  const outputPath = path.join(process.cwd(), 'engine', 'ComponentStyleBundle.ts');
  await writeFile(outputPath, fileContent);

  console.log(`Style bundle generated: ${outputPath}`);
  if (componentsWithCSS.length > 0) {
    console.log(`Copied ${copiedCount} CSS file(s) for ${componentsWithCSS.length} component(s)`);
  } else {
    console.log('No component CSS files found to bundle');
  }
}

/**
 * Generate design system CSS bundle
 * Wraps global design system CSS in @layer preview-global scoped to preview container
 */
async function generateDesignSystemCSS(config: TranslationConfig): Promise<void> {
  const cssPaths = config.preview?.designSystem?.css || [];

  if (cssPaths.length === 0) {
    // Create empty file to avoid import errors
    const fileContent = `/**
 * Design System CSS
 *
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by: bun run context:build
 *
 * No design system CSS configured
 */
`;
    const outputPath = path.join(process.cwd(), 'engine', 'design-system.css');
    await writeFile(outputPath, fileContent);
    return;
  }

  // Read all CSS files
  const cssContents: string[] = [];
  for (const cssPath of cssPaths) {
    const resolvedPath = path.resolve(process.cwd(), cssPath);
    if (!existsSync(resolvedPath)) {
      console.warn(`Warning: Design system CSS file not found: ${cssPath}`);
      continue;
    }
    const content = await readFile(resolvedPath, 'utf-8');
    cssContents.push(content);
  }

  if (cssContents.length === 0) {
    console.warn('Warning: No design system CSS files could be loaded');
    return;
  }

  // Wrap in @layer preview-global and scope to preview container
  const combinedCSS = cssContents.join('\n\n');
  const fileContent = `/**
 * Design System CSS
 *
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by: bun run context:build
 *
 * This file contains global design system styles wrapped in @layer preview-global
 * and scoped to .component-preview-container for isolation
 */

@layer preview-global {
  .component-preview-container {
${combinedCSS.split('\n').map(line => '    ' + line).join('\n')}
  }
}
`;

  const outputPath = path.join(process.cwd(), 'engine', 'design-system.css');
  await writeFile(outputPath, fileContent);
  console.log(`Design system CSS generated: ${outputPath}`);
  console.log(`Loaded ${cssPaths.length} CSS file(s)`);
}

/**
 * Generate design system wrapper bundle
 * Creates a wrapper component that provides design system context
 */
async function generateDesignSystemBundle(config: TranslationConfig): Promise<void> {
  const wrapper = config.preview?.designSystem?.wrapper;

  if (!wrapper) {
    // Generate pass-through wrapper
    const fileContent = `/**
 * Design System Wrapper
 *
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by: bun run context:build
 *
 * No wrapper configured - pass-through component
 */

import React from 'react';

export function DesignSystemWrapper({ children }: { children: React.ReactNode }) {
  return <>{children}</>;
}
`;
    const outputPath = path.join(process.cwd(), 'engine', 'DesignSystemBundle.tsx');
    await writeFile(outputPath, fileContent);
    return;
  }

  // Generate wrapper with imports
  const importPath = path.relative(
    path.join(process.cwd(), 'engine'),
    path.resolve(process.cwd(), wrapper.import)
  ).replace(/\.tsx?$/, '').replace(/\\/g, '/');

  const importStatement = wrapper.exportType === 'default'
    ? `import Provider from '${importPath.startsWith('.') ? importPath : './' + importPath}';`
    : `import { ${wrapper.exportType} as Provider } from '${importPath.startsWith('.') ? importPath : './' + importPath}';`;

  const propsString = wrapper.props ? JSON.stringify(wrapper.props, null, 2) : '{}';

  const fileContent = `/**
 * Design System Wrapper
 *
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by: bun run context:build
 *
 * This wrapper provides design system context to preview components
 */

import React from 'react';
${importStatement}

const wrapperProps = ${propsString};

export function DesignSystemWrapper({ children }: { children: React.ReactNode }) {
  return (
    <Provider {...wrapperProps}>
      {children}
    </Provider>
  );
}
`;

  const outputPath = path.join(process.cwd(), 'engine', 'DesignSystemBundle.tsx');
  await writeFile(outputPath, fileContent);
  console.log(`Design system wrapper generated: ${outputPath}`);
}

/**
 * Generate design system initialization bundle
 * Creates initialization function for design systems that require setup
 */
async function generateDesignSystemInit(config: TranslationConfig): Promise<void> {
  const init = config.preview?.designSystem?.init;

  if (!init) {
    // Generate no-op function
    const fileContent = `/**
 * Design System Initialization
 *
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by: bun run context:build
 *
 * No initialization configured
 */

export function initDesignSystemPreview() {
  // No initialization needed
}
`;
    const outputPath = path.join(process.cwd(), 'engine', 'DesignSystemInit.ts');
    await writeFile(outputPath, fileContent);
    return;
  }

  // Generate init with imports
  const importPath = path.relative(
    path.join(process.cwd(), 'engine'),
    path.resolve(process.cwd(), init.import)
  ).replace(/\.tsx?$/, '').replace(/\\/g, '/');

  const importStatement = init.exportType === 'default'
    ? `import initFn from '${importPath.startsWith('.') ? importPath : './' + importPath}';`
    : `import { ${init.functionName} as initFn } from '${importPath.startsWith('.') ? importPath : './' + importPath}';`;

  const argsString = init.args ? JSON.stringify(init.args, null, 2) : '{}';

  const fileContent = `/**
 * Design System Initialization
 *
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by: bun run context:build
 *
 * This function initializes the design system for preview
 */

${importStatement}

const initArgs = ${argsString};

export function initDesignSystemPreview() {
  initFn(initArgs);
}
`;

  const outputPath = path.join(process.cwd(), 'engine', 'DesignSystemInit.ts');
  await writeFile(outputPath, fileContent);
  console.log(`Design system init generated: ${outputPath}`);
}

async function main() {
  try {
    console.log('Starting application analysis...\n');

    // Load project configuration
    const config = await loadConfig();
    console.log(`Loaded config: ${config.name}`);
    console.log(`Source directory: ${config.sourceDir}\n`);

    // Create analyzer with config
    const analyzerConfig = configToAnalyzerConfig(config);
    const analyzer = new Analyzer(analyzerConfig);

    // Run analysis
    const contextApp = await analyzer.analyze();

    // Add project root directory to context
    contextApp.rootDir = process.cwd();

    // Load translation files
    const translationsDir = path.join(process.cwd(), config.sourceDir, 'translations');
    const translationValues: Record<string, Record<string, string>> = {};

    if (existsSync(translationsDir)) {
      const { readdir } = await import('fs/promises');
      const files = await readdir(translationsDir);

      for (const file of files) {
        if (file.endsWith('-translation.json') || file.endsWith('.json')) {
          try {
            const filePath = path.join(translationsDir, file);
            const content = await readFile(filePath, 'utf-8');
            const translations = JSON.parse(content);

            // Extract locale from filename (e.g., 'en-translation.json' -> 'en')
            const locale = file.replace('-translation.json', '').replace('.json', '');
            translationValues[locale] = translations;

            console.log(`Loaded translation file: ${file} (${locale})`);
          } catch (error) {
            console.warn(`Failed to load translation file ${file}:`, error);
          }
        }
      }
    }

    // Add translation values to context
    contextApp.translationValues = translationValues;

    // Write output to context.json
    const contextPath = path.join(process.cwd(), 'context.json');
    await writeFile(contextPath, JSON.stringify(contextApp, null, 2));

    console.log(`\nContext file generated: ${contextPath}`);
    console.log(`Found ${contextApp.rootComponents.length} root component(s)`);

    // Display summary
    const totalComponents = Object.keys(contextApp.components).length;
    const totalTranslations = Object.keys(contextApp.translations).length;

    console.log(`Total components: ${totalComponents}`);
    console.log(`Total translation keys: ${totalTranslations}\n`);

    // Generate ComponentBundle.ts
    await generateComponentBundle(contextApp, config);

    // Generate ComponentStyleBundle.ts (CSS files)
    await generateStyleBundle(contextApp, config);

    // Generate design system bundles
    await generateDesignSystemCSS(config);
    await generateDesignSystemBundle(config);
    await generateDesignSystemInit(config);

    console.log('\nâœ“ Build completed successfully!');

  } catch (error) {
    console.error('Error during analysis:', error);
    process.exit(1);
  }
}

main();
